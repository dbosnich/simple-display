# Simple Display


### Overview
SimpleDisplay is a C++ framework/static library that can be used
to create, show, hide, render, and interact with display devices.

Designed primarily for simple applications that need to display
a rendered image to the system display (or a window) each frame.

The primary design consideration was ease-of-use, although every
effort has been made to not compromise efficiency or flexibility.


### Features
#### Display Buffer
  The Simple::Display::Buffer class encapsulates functionality
  for creating, resizing, and rendering to a pixel buffer that
  can then be presented to a display device/window each frame.

#### Display Context
  The Simple::Display::Context class provides functionality to
  present a pixel buffer to a display device/window each frame,
  acting as a link between the native system and graphics API.

#### Display Window
  The Simple::Display::Window class encapsulates functionality
  for creating, resizing, and updating a native system window,
  which doubles as a display device for all desktop platforms.

#### Platform Agnostic Interfaces
  Public interfaces provided by the Simple::Display framework
  are designed to be platform agnostic, although some leakage
  of platform specific concepts is tolerated provided they do
  not negatively impact any of the other supported platforms.

#### Platform Specific Implementations
  Simple::Display::Buffer and Simple::Display::Context classes
  can be configured with any graphics API that is supported by
  the host platform: OpenGL, Vulkan, or Native (DirectX|Metal).
  Simple::Display::Window class is entirely platform dependent.

#### RAII (resource acquisition is initialization)
  All of the resources required by the Simple::Display::Buffer,
  Simple::Display::Context and Simple::Display::Window classes
  are acquired during construction and released on destruction,
  although resizing a buffer may result in some re-allocations.


### API Documentation
The public API documentation is built using the DOC_BUILD target
generated by CMake (but only if the Doxygen dependency is found).


### Unit Tests
CMake can be used to generate test projects (eg. VS, Xcode, make)
that build/run the suite of unit tests found in the tests folder.


### Supported Platforms
This project has been tested using the following C++14 compilers:
- msvc (Visual Studio 2022)
- clang (Xcode 15)
- gcc (make)


### Example
The following is a small sample of the core functionality which
is provided by the framework. The above mentioned test suite is
also a good reference that demonstrates a broader range of uses.

#### MyApplication.h
```
#include <simple/application/application.h>
#include <simple/display/context.h>

class MyApplication : public Simple::Application
{
protected:
    void StartUp() override;
    void ShutDown() override;

    void UpdateStart(float a_deltaTimeSeconds) override;
    void UpdateFixed(float a_fixedTimeSeconds) override;
    void UpdateEnded(float a_deltaTimeSeconds) override;

private:
    void SetPixelBufferColor(const float* a_color);

    Simple::Display::Context* m_context = nullptr;
    float m_secondsElapsed = 0.0f;
};
```

#### MyApplication.cpp
```
#include "MyApplication.h"

using namespace Simple::Display;

void MyApplication::StartUp()
{
    // Create the display context.
    Context::Config config;
    config.bufferConfig.format = Buffer::Format::RGBA_FLOAT;
    config.windowConfig.titleUTF8 = "Simple Application Window";
    m_context = new Context(config);
}

void MyApplication::ShutDown()
{
    // Destroy the display context.
    delete m_context;
    m_context = nullptr;
}

void MyApplication::UpdateStart(float a_deltaTimeSeconds)
{
    // Process window events.
    m_context->OnFrameStart();
}

void MyApplication::UpdateFixed(float a_fixedTimeSeconds)
{
    m_secondsElapsed += a_fixedTimeSeconds;

    // Change the color of the pixel buffer every second.
    static constexpr float R[4] = { 1.0f, 0.0f, 0.0f, 1.0f };
    static constexpr float G[4] = { 0.0f, 1.0f, 0.0f, 1.0f };
    static constexpr float B[4] = { 0.0f, 0.0f, 1.0f, 1.0f };
    static constexpr const float* COLORS[3] = { R, G, B };
    SetPixelBufferColor(COLORS[(int)m_secondsElapsed % 3]);

    // Shut down once the window has been closed.
    const Window* window = m_context->GetWindow();
    if (window && window->IsClosed())
    {
        RequestShutDown();
    }
}

void MyApplication::UpdateEnded(float a_deltaTimeSeconds)
{
    // Render the pixel buffer and present to the display.
    m_context->OnFrameEnded();
}

void MyApplication::SetPixelBufferColor(const float* a_color)
{
    Buffer& buffer = m_context->GetBuffer();
    float* data = buffer.GetData<float>();
    if (!data)
    {
        return;
    }

    const uint32_t numChannelsPerPixel = Buffer::ChannelsPerPixel(buffer.GetFormat());
    const uint32_t totalPixels = buffer.GetWidth() * buffer.GetHeight();
    const uint32_t totalChannels = totalPixels * numChannelsPerPixel;
    for (uint32_t i = 0; i < totalChannels; i += numChannelsPerPixel)
    {
        for (uint32_t j = 0; j < numChannelsPerPixel; ++j)
        {
            data[i + j] = a_color[j];
        }
    }
}
```

#### main.cpp
```
#include "MyApplication.h"

int main(int argc, char* argv[])
{
    MyApplication myApplication;
    myApplication.Run();
}
```


### Authors
- David Bosnich - <david.bosnich.public@gmail.com>


### License
Copyright (c) David Bosnich <david.bosnich.public@gmail.com>

This code is licensed under the MIT License, a copy of which
can be found in the license.txt file included at the root of
this distribution, or at https://opensource.org/licenses/MIT
